<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mahjong Hand Analyzer (Simple)</title>
    <style>
        body { font-family: sans-serif; max-width: 600px; margin: 2em auto; }
        button { margin: 0.5em 0.5em 0.5em 0; padding: 0.5em 1.2em; font-size: 1em; }
        #handDisplay { font-size: 1.1em; margin: 1em 0; background: #f8f8f8; padding: 0.5em; border-radius: 4px; min-width: 690px; white-space: nowrap; overflow-x: auto; }
        pre { background: #f3f3f3; padding: 1em; border-radius: 4px; }
        #analysisSummaryDisplay {
            background: #e8f0fe; /* Light blue background */
            padding: 0.5em;
            border-radius: 4px;
            margin-bottom: 1em; /* Space before detailed JSON results */
            border: 1px solid #cddcec;
        }
        .summary-row {
            padding: 0.25em 0.5em;
            font-family: monospace;
            border-bottom: 1px dashed #d0d8e0;
        }
        .summary-row:last-child {
            border-bottom: none;
        }
        .tile {
            width: 45px; /* Adjusted for better fit */
            height: 65px; /* Adjusted for better fit */
            border: 1px solid #999;
            border-radius: 4px;
            background-color: #fff9f0; /* Light cream */
            margin: 2px;
            display: inline-flex; /* For horizontal layout */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none;
            font-size: 18px; /* Larger number */
            font-weight: bold;
            text-align: center;
            padding: 2px;
            box-sizing: border-box;
            position: relative; /* For potential absolute positioning of suit symbols */
        }
        .tile span { /* For the small suit letter */
            font-size: 0.6em;
            font-weight: normal;
            position: absolute;
            bottom: 2px;
            right: 4px;
        }
        .tile.joker { background-color: #e6e6fa; color: #551a8b; } /* Lavender */
        .tile.flower { background-color: #fffacd; color: #ff4500; } /* Lemon chiffon */
        .tile.wind { background-color: #add8e6; color: #00008b; } /* Light blue */
        .tile.dragon { background-color: #90ee90; color: #006400; } /* Default Light green for dragons */
        .tile.dragon-rd { background-color: #ffcccb; color: #dc143c; } /* Light Red background, Crimson text for Red Dragon */
        .tile.dragon-gd { background-color: #90ee90; color: #006400; } /* Explicit Light Green for Green Dragon */
        .tile.dragon-wd { background-color: #f8f8ff; color: #404040; } /* Ghost White background, Dark Gray text for White Dragon */
        .tile.bam { color: #006400; } /* Dark Green for Bamboo */
        .tile.crack { color: #dc143c; } /* Crimson for Characters */
        .tile.dot { color: #00008b; } /* Dark Blue for Dots */
    </style>
</head>
<body>
<h2>Mahjong Hand Analyzer (Simple)</h2>
<button id="generateBtn">Generate Random Hand</button>
<button id="analyzeBtn">Analyze Hand</button>
<button id="sortSuitBtn">Sort by Suit</button>
<button id="sortNumBtn">Sort by Number</button>
<div id="handDisplay">(No hand yet)</div>
<div id="analysisSummaryDisplay"></div>
<pre id="resultDisplay">(No analysis yet)</pre>
<script>
// --- Tile Set (simplified, update as needed) ---
const TILES = [
    ...Array.from({length: 9}, (_,i) => `${i+1}bam`),
    ...Array.from({length: 9}, (_,i) => `${i+1}crack`),
    ...Array.from({length: 9}, (_,i) => `${i+1}dot`),
    'rd','gd','wd', // Dragons
    'e','s','w','n', // Winds
    'F','F','F','F' // Flowers (all are 'F' as they are interchangeable)
];

// --- Random Hand Generator ---
function generateRandomHand(size=14) {
    const pool = [...TILES, ...TILES, ...TILES, ...TILES]; // 4 of each tile
    for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    return pool.slice(0, size);
}

// --- Hand Analysis Logic (real) ---

// Helper: Base class for hand templates
class HandTemplate {
    constructor(config) {
        this.templateId = config.templateId;
        this.name = config.name;
        this.description = config.description;
        this.category = config.category;
        this.pointValue = config.pointValue || 1;
        this.number = config.number || null;
    }
    generateVariations() {
        throw new Error('Subclasses must implement generateVariations');
    }
    validateHand(tiles) {
        throw new Error('Subclasses must implement validateHand');
    }
}

// --- Template 1: SequenceAndKongsTemplate ---
class SequenceAndKongsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'sequence_and_kongs',
            name: 'Sequence and Kongs',
            description: 'Pair of the starting number, sequence of 5 in one suit (starting with the pair), and kongs of the starting number in the other two suits',
            category: 'Sequences',
            pointValue: 30,
            number: 1
        });
    }
    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot'];
        for (const seqSuit of SUITS) {
            for (let startNum = 1; startNum <= 5; startNum++) {
                const variation = [];
                let groupIndex = 0;
                // Pair of the starting number in the sequence suit
                for (let i = 0; i < 2; i++) {
                    const tileCode = `${startNum}${seqSuit}`;
                    variation.push({
                        type: 'pair', tile: tileCode, value: tileCode, groupIndex, position: i
                    });
                }
                groupIndex++;
                // Sequence of 4 more tiles (to make a 5-tile sequence with the pair)
                for (let i = 1; i < 5; i++) {
                    const tileCode = `${startNum + i}${seqSuit}`;
                    variation.push({
                        type: 'sequence', tile: tileCode, value: tileCode, groupIndex, position: i
                    });
                }
                groupIndex++;
                // Two kongs of the starting number in the other two suits
                let kongsAdded = 0;
                for (const kongSuit of SUITS) {
                    if (kongSuit !== seqSuit && kongsAdded < 2) {
                        for (let i = 0; i < 4; i++) {
                            const tileCode = `${startNum}${kongSuit}`;
                            variation.push({
                                type: 'kong', tile: tileCode, value: tileCode, groupIndex, position: i
                            });
                        }
                        groupIndex++;
                        kongsAdded++;
                    }
                }
                variations.push({
                    name: `Pair ${startNum}${seqSuit}, sequence ${startNum}-${startNum+4}${seqSuit}, kongs of ${startNum} in other suits`,
                    slots: variation
                });
            }
        }
        return variations;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 2: Symmetrical13579AllSuitsTemplate ---
class Symmetrical13579AllSuitsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'symmetrical_13579_all_suits',
            name: '13579 Symmetrical - All 3 suits',
            description: 'Pair of 1s (suit1), Pung of 3s (suit1), Kong of 5s (suit2), Pung of 7s (suit3), Pair of 9s (suit3).',
            category: '13579',
            pointValue: 25,
            number: 2
        });
    }

    _createTileGroup(tileCode, count, type, groupIndex) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type: type,
                tile: tileCode,
                value: tileCode, 
                groupIndex: groupIndex,
                position: i
            });
        }
        return group;
    }

    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot'];

        for (const suit1 of SUITS) {
            for (const suit2 of SUITS) {
                if (suit1 === suit2) continue;
                for (const suit3 of SUITS) {
                    if (suit3 === suit1 || suit3 === suit2) continue;

                    const variation = [];
                    let groupIndex = 0;

                    // Pair - 1, suit1
                    variation.push(...this._createTileGroup(`1${suit1}`, 2, 'pair', groupIndex++));
                    // Pung - 3, suit1
                    variation.push(...this._createTileGroup(`3${suit1}`, 3, 'pung', groupIndex++));
                    // Kong - 5, suit2
                    variation.push(...this._createTileGroup(`5${suit2}`, 4, 'kong', groupIndex++));
                    // Pung - 7, suit3
                    variation.push(...this._createTileGroup(`7${suit3}`, 3, 'pung', groupIndex++));
                    // Pair - 9, suit3
                    variation.push(...this._createTileGroup(`9${suit3}`, 2, 'pair', groupIndex++));
                    
                    variations.push({
                        name: `13579 Sym: S1=${suit1}, S2=${suit2}, S3=${suit3}`,
                        slots: variation,
                        description: `1s(${suit1}), 3s(${suit1}), 5s(${suit2}), 7s(${suit3}), 9s(${suit3})`
                    });
                }
            }
        }
        return variations;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 3: KongKongPairWithFlowersAndDragonsTemplate ---
class KongKongPairWithFlowersAndDragonsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'kong_kong_pair_flowers_dragons',
            name: 'Kong Kong Pair with Flowers and Dragons',
            description: 'Pair of Flowers, two kongs of the same number in different suits with single dragons, and a pair of the same number in a third suit',
            category: 'Special',
            pointValue: 25,
            number: 1
        });
    }
    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot'];
        for (let number = 1; number <= 9; number++) {
            for (let i = 0; i < SUITS.length; i++) {
                for (let j = 0; j < SUITS.length; j++) {
                    if (i === j) continue;
                    const variation = [];
                    let groupIndex = 0;
                    // Pair of flowers
                    variation.push(...this._createTileGroup('F', 2, 'pair', groupIndex++, true)); // Pair of generic Flowers
                    // Kongs
                    variation.push(...this._createTileGroup(`${number}${SUITS[i]}`, 4, 'kong', groupIndex++));
                    variation.push(...this._createTileGroup(`${number}${SUITS[j]}`, 4, 'kong', groupIndex++));
                    // Pair in remaining suit
                    const remainingSuit = SUITS.find((_, idx) => idx !== i && idx !== j);
                    variation.push(...this._createTileGroup(`${number}${remainingSuit}`, 2, 'pair', groupIndex++));
                    // Single dragons
                    variation.push(...this._createTileGroup('rd', 1, 'single', groupIndex++));
                    variation.push(...this._createTileGroup('gd', 1, 'single', groupIndex++));
                    if (variation.length === 14) {
                        variations.push({
                            name: `Kong Kong Pair with ${number}s and Dragons`,
                            slots: variation,
                            description: `Pair of flowers, kongs of ${number}${SUITS[i]} and ${number}${SUITS[j]}, pair of ${number}${remainingSuit}, and single dragons`
                        });
                    }
                }
            }
        }
        return variations;
    }
    _createTileGroup(tileCode, count, type, groupIndex, isFlower = false) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type, value: tileCode, tile: tileCode, groupIndex, position: i, isFlower
            });
        }
        return group;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 4: EvenChowEvenPungsFlowersTemplate ---
class EvenChowEvenPungsFlowersTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'even_chow_even_pungs_flowers',
            name: 'Even Chow + Even Pungs + Flowers',
            description: 'Kong of Flowers, singles of 2,4,6,8 in one suit, and pungs of the same even number in the other two suits',
            category: 'Even Numbers',
            pointValue: 35,
            number: 4
        });
    }
    generateVariations() {
        const variations = [];
        const evenNumbers = [2, 4, 6, 8];
        const SUITS = ['bam', 'crack', 'dot'];
        for (const evenNum of evenNumbers) {
            for (const chowSuit of SUITS) {
                for (const pungSuit1 of SUITS) {
                    if (pungSuit1 === chowSuit) continue;
                    for (const pungSuit2 of SUITS) {
                        if (pungSuit2 === chowSuit || pungSuit2 === pungSuit1) continue;
                        const variation = [];
                        let groupIndex = 0;
                        variation.push(...this._createTileGroup('F', 4, 'kong', groupIndex++)); // Kong of generic Flowers
                        for (const num of evenNumbers) {
                            variation.push(...this._createTileGroup(`${num}${chowSuit}`, 1, 'single', groupIndex++, 1));
                        }
                        variation.push(...this._createTileGroup(`${evenNum}${pungSuit1}`, 3, 'pung', groupIndex++));
                        variation.push(...this._createTileGroup(`${evenNum}${pungSuit2}`, 3, 'pung', groupIndex++));
                        if (variation.length === 14) {
                            variations.push({
                                name: `Even ${evenNum} - ${chowSuit} chow, ${pungSuit1}/${pungSuit2} pungs`,
                                slots: variation,
                                description: `Kong of Flowers, singles of 2,4,6,8 in ${chowSuit}, pungs of ${evenNum} in ${pungSuit1} and ${pungSuit2}`
                            });
                        }
                    }
                }
            }
        }
        return variations;
    }
    _createTileGroup(tileCode, count, type, groupIndex, position = 0) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type, tile: tileCode, value: tileCode, groupIndex, position: position === 0 ? i : position
            });
        }
        return group;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- TileMatcher ---
class TileMatcher {
    constructor() { this.reset(); }
    reset() {
        this.hand = [];
        this.variation = [];
        this.availableJokers = 0;
        this.usedJokers = 0;
        this.matchedTiles = [];
        this.variationCopy = [];
    }
    matchVariation(hand, variation, availableJokers = 0) {
        this.reset();
        this.hand = [...hand];
        this.variation = variation.slots || variation;
        this.availableJokers = availableJokers;
        this.variationCopy = JSON.parse(JSON.stringify(this.variation));

        // First pass: try to match exact tiles
        this.matchExactTiles();
        // Second pass: use jokers to fill remaining slots in valid groups
        this.matchWithJokers();
        const score = this.calculateScore();
        const maxPossibleScore = this.variation.length;
        const resultToReturn = {
            score,
            maxPossibleScore,
            matchedTiles: [...this.matchedTiles],
            matchedTilesCount: this.matchedTiles.length, // Ensure this is returned for summary
            usedJokers: this.usedJokers,
            variation: this.variationCopy
        };
        return resultToReturn;
    }
    matchExactTiles() {
        const handCopy = [...this.hand];
        for (let i = 0; i < handCopy.length; i++) {
            const tile = handCopy[i];
            if (tile === undefined || tile === null) continue;
            let matched = false;
            for (let j = 0; j < this.variation.length; j++) {
                const slot = this.variation[j];
                if (slot.matched) continue;
                if (!slot || slot.tile === undefined) continue;
                if (this.tilesMatch(tile, slot.tile)) {
                    slot.matched = true;
                    slot.usedJoker = false;
                    this.matchedTiles.push(tile);
                    handCopy.splice(i, 1);
                    i--;
                    matched = true;
                    break;
                }
            }
        }
        this.hand = handCopy;
    }
    matchWithJokers() {
        // Only use jokers if we have some available
        if (this.availableJokers <= 0) return;
        // Find all unmatched slots that are part of a valid group
        // (For simplicity, just fill unmatched slots with jokers)
        for (let j = 0; j < this.variation.length && this.availableJokers > 0; j++) {
            const slot = this.variation[j];
            if (!slot.matched) {
                slot.matched = true;
                slot.usedJoker = true;
                this.matchedTiles.push('joker');
                this.usedJokers++;
                this.availableJokers--;
            }
        }
    }
    calculateScore() {
        // Score: number of matched slots (excluding jokers)
        return this.matchedTiles.filter(t => t !== 'joker').length;
    }
    tilesMatch(tileA, tileB) {
        // Case-insensitive match
        return (tileA || '').toLowerCase() === (tileB || '').toLowerCase();
    }
}

// --- HandAnalyzer ---
class HandAnalyzer {
    constructor() {
        this.templates = [];
        this.tileMatcher = new TileMatcher();
        this.initializeTemplates();
    }
    initializeTemplates() {
        this.templates.push(new SequenceAndKongsTemplate());
        this.templates.push(new Symmetrical13579AllSuitsTemplate());
        this.templates.push(new KongKongPairWithFlowersAndDragonsTemplate());
        this.templates.push(new EvenChowEvenPungsFlowersTemplate());
    }
    analyzeHand(hand) {
        if (!hand || hand.length === 0) {
            return [];
        }
        const nonJokerTiles = hand.filter(tile => !tile.startsWith('j'));
        const jokers = hand.length - nonJokerTiles.length;
        const results = [];
        this.templates.forEach(template => {
            const { bestOverallMatch, maxMatchedTilesCount, countMaxTilesVariations } = this.analyzeTemplate(template, nonJokerTiles, jokers);

            if (bestOverallMatch) { // A best overall match (by score) was found
                results.push({
                    templateId: template.templateId,
                    templateName: template.name,
                    category: template.category,
                    pointValue: template.pointValue,
                    ...bestOverallMatch, // Spread details of the highest scoring match for detailed view
                    summaryMatchedTiles: maxMatchedTilesCount, // 't' for summary
                    summaryVariationCount: countMaxTilesVariations // 'v' for summary
                });
            }
        });
        results.sort((a, b) => b.score - a.score);
        return results;
    }
    analyzeTemplate(template, nonJokerTiles, availableJokers) {
        let bestOverallMatch = null;
        let maxMatchedTilesCount = -1;
        let countMaxTilesVariations = 0;
        const allMatchResults = []; // This will store results from the first loop

        const variations = template.generateVariations();

        if (!variations || variations.length === 0) {
            return { bestOverallMatch: null, maxMatchedTilesCount: 0, countMaxTilesVariations: 0 };
        }

        // 1st loop: find maxMatchedTilesCount and bestOverallMatch
        for (let i = 0; i < variations.length; i++) {
            const variation = variations[i];
            const matchResult = this.tileMatcher.matchVariation(nonJokerTiles, variation, availableJokers);
            allMatchResults.push(matchResult);

            if (!bestOverallMatch || matchResult.score > bestOverallMatch.score) {
                bestOverallMatch = matchResult;
            }

            if (matchResult.matchedTilesCount > maxMatchedTilesCount) {
                maxMatchedTilesCount = matchResult.matchedTilesCount;
            }
        }

        // 2nd loop: count variations achieving maxMatchedTilesCount
        if (maxMatchedTilesCount > -1 && allMatchResults.length > 0) {
            for (let i = 0; i < allMatchResults.length; i++) {
                const res = allMatchResults[i];
                if (res.matchedTilesCount === maxMatchedTilesCount) {
                    countMaxTilesVariations++;
                }
            }
        }
        return { bestOverallMatch, maxMatchedTilesCount, countMaxTilesVariations };
    }
}
const handAnalyzer = new HandAnalyzer();

function createTileElement(tileCode) {
    if (!tileCode) return null;

    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.dataset.code = tileCode; // Store original code for debugging/sorting

    let suit = '', value = '';

    if (tileCode.startsWith('j')) { // Joker
        tile.textContent = 'JOK'; // Short for Joker
        tile.classList.add('joker');
        suit = 'JOKER';
        value = tileCode; // e.g., j1
    } else if (tileCode === 'F') { // Flower
        tile.textContent = 'FLR'; // Short for Flower
        tile.classList.add('flower');
        suit = 'FLOWER';
        value = 'F';
    } else if (['e', 's', 'w', 'n'].includes(tileCode.toLowerCase())) { // Winds
        tile.textContent = tileCode.toUpperCase();
        tile.classList.add('wind');
        suit = 'WIND';
        value = tileCode;
    } else if (['rd', 'gd', 'wd'].includes(tileCode.toLowerCase())) { // Dragons
        tile.textContent = tileCode.toUpperCase();
        tile.classList.add('dragon');
        if (tileCode.toLowerCase() === 'rd') tile.classList.add('dragon-rd');
        else if (tileCode.toLowerCase() === 'gd') tile.classList.add('dragon-gd');
        else if (tileCode.toLowerCase() === 'wd') tile.classList.add('dragon-wd');
        suit = 'DRAGON';
        value = tileCode;
    } else { // Suited tiles: 1bam, 5dot, 9crack etc.
        const match = tileCode.match(/^(\d+)([a-z]+)$/);
        if (match) {
            const num = match[1];
            const suitName = match[2];
            tile.textContent = num; // Display the number
            const suitSpan = document.createElement('span');
            // suitSpan.style.fontSize = '0.7em'; // Handled by .tile span CSS
            // suitSpan.style.display = 'block';
            suitSpan.textContent = suitName.substring(0,1).toUpperCase(); // B, C, D
            tile.appendChild(suitSpan);

            tile.classList.add(suitName); // e.g., 'bam', 'crack', 'dot' for specific styling
            suit = suitName.toUpperCase();
            value = num;
        } else {
            tile.textContent = tileCode; // Fallback for unknown
        }
    }
    tile.dataset.suit = suit;
    tile.dataset.value = value; // Store parsed value for sorting

    return tile;
}

const SUIT_ORDER = { BAM: 1, CRACK: 2, DOT: 3, WIND: 4, DRAGON: 5, FLOWER: 6, JOKER: 7 };
const WIND_ORDER = { e: 1, s: 2, w: 3, n: 4 };
const DRAGON_ORDER = { rd: 1, gd: 2, wd: 3 };

function getTileSortableValues(tileCode) {
    let suit, valueNum, suitOrder, valueOrder;

    if (tileCode.startsWith('j')) {
        suit = 'JOKER';
        valueNum = parseInt(tileCode.substring(1)) || 0;
    } else if (tileCode === 'F') {
        suit = 'FLOWER';
        valueNum = 1;
    } else if (['e', 's', 'w', 'n'].includes(tileCode.toLowerCase())) {
        suit = 'WIND';
        valueNum = WIND_ORDER[tileCode.toLowerCase()];
    } else if (['rd', 'gd', 'wd'].includes(tileCode.toLowerCase())) {
        suit = 'DRAGON';
        valueNum = DRAGON_ORDER[tileCode.toLowerCase()];
    } else {
        const match = tileCode.match(/^(\d+)([a-z]+)$/);
        if (match) {
            valueNum = parseInt(match[1]);
            suit = match[2].toUpperCase();
        } else {
            suit = 'UNKNOWN'; valueNum = 99;
        }
    }
    suitOrder = SUIT_ORDER[suit] || 99;
    valueOrder = valueNum;
    return { suit, valueNum, suitOrder, valueOrder };
}

function sortHand(handArray, sortBySuitPrimary = true) {
    handArray.sort((a, b) => {
        const valA = getTileSortableValues(a);
        const valB = getTileSortableValues(b);

        if (sortBySuitPrimary) {
            if (valA.suitOrder !== valB.suitOrder) {
                return valA.suitOrder - valB.suitOrder;
            }
            return valA.valueOrder - valB.valueOrder;
        } else { // Sort by Number (value) first
            if (valA.valueOrder !== valB.valueOrder) {
                return valA.valueOrder - valB.valueOrder;
            }
            return valA.suitOrder - valB.suitOrder;
        }
    });
}

function renderHand(handArray, displayElement) {
    displayElement.innerHTML = ''; // Clear previous display
    if (!handArray || handArray.length === 0) {
        displayElement.textContent = '(No hand yet)';
        return;
    }
    handArray.forEach(tileCode => {
        const tileEl = createTileElement(tileCode);
        if (tileEl) {
            displayElement.appendChild(tileEl);
        }
    });
}

// --- UI Logic ---
let currentHand = [];
const handDisplay = document.getElementById('handDisplay');
const resultDisplay = document.getElementById('resultDisplay');

document.getElementById('generateBtn').onclick = function() {
    currentHand = generateRandomHand();
    renderHand(currentHand, handDisplay);
    resultDisplay.textContent = '(No analysis yet)';
    const summaryDisplayElement = document.getElementById('analysisSummaryDisplay');
    if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear summary display
};
document.getElementById('analyzeBtn').onclick = function() {
    const detailedResultDisplay = document.getElementById('resultDisplay');
    const summaryDisplayElement = document.getElementById('analysisSummaryDisplay'); // Get reference

    if (!currentHand || currentHand.length === 0) { // More robust check
        if(detailedResultDisplay) detailedResultDisplay.textContent = '(Generate a hand first)';
        if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear summary display as well
        return;
    }
    const analysisResultsArray = handAnalyzer.analyzeHand(currentHand);

    // Populate Summary Display
    if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear previous summary
    if (analysisResultsArray && analysisResultsArray.length > 0) {
        analysisResultsArray.forEach(templateAnalysis => {
            const row = document.createElement('div');
            row.className = 'summary-row';
            row.dataset.templateId = templateAnalysis.templateId; // For future click functionality
            row.textContent = `${templateAnalysis.templateName} tiles=${templateAnalysis.summaryMatchedTiles} vars=${templateAnalysis.summaryVariationCount}`;
            if (summaryDisplayElement) summaryDisplayElement.appendChild(row);
        });
    } else {
        if (summaryDisplayElement) summaryDisplayElement.textContent = '(No analysis summary available)';
    }

    // Populate Detailed JSON Display
    const jsonString = JSON.stringify(analysisResultsArray, null, 2);
    detailedResultDisplay.textContent = jsonString;
};

document.getElementById('sortSuitBtn').onclick = function() {
    if (!currentHand.length) return;
    sortHand(currentHand, true); // true for sortBySuitPrimary
    renderHand(currentHand, handDisplay);
};

document.getElementById('sortNumBtn').onclick = function() {
    if (!currentHand.length) return;
    sortHand(currentHand, false); // false for sortBySuitPrimary (so sort by number first)
    renderHand(currentHand, handDisplay);
};
</script>
</body>
</html>
