<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mahjong Hand Analyzer (Simple)</title>
    <style>
        body { font-family: sans-serif; max-width: 600px; margin: 2em auto; }
        button { margin: 0.5em 0.5em 0.5em 0; padding: 0.5em 1.2em; font-size: 1em; }
        #handDisplay { font-size: 1.1em; margin: 1em 0; background: #f8f8f8; padding: 0.5em; border-radius: 4px; min-width: 690px; white-space: nowrap; overflow-x: auto; }
        pre { background: #f3f3f3; padding: 1em; border-radius: 4px; }
        #analysisSummaryDisplay {
            background: #e8f0fe; /* Light blue background */
            padding: 0.5em;
            border-radius: 4px;
            margin-bottom: 1em; /* Space before detailed JSON results */
            border: 1px solid #cddcec;
        }
        .summary-row {
            padding: 0.25em 0.5em;
            font-family: monospace;
            border-bottom: 1px dashed #d0d8e0;
        }
        .summary-row:last-child {
            border-bottom: none;
        }
        .summary-row .variation-display {
            font-style: italic;
            font-size: 0.9em;
            color: #555;
            margin-left: 10px;
        }
        .tile-highlighted {
            border: 3px solid gold !important; /* !important to ensure override */
            box-shadow: 0 0 10px gold;
            transform: scale(1.05); /* Slightly enlarge highlighted tiles */
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .tile {
            width: 45px; /* Adjusted for better fit */
            height: 65px; /* Adjusted for better fit */
            border: 1px solid #999;
            border-radius: 4px;
            background-color: #fff9f0; /* Light cream */
            margin: 2px;
            display: inline-flex; /* For horizontal layout */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none;
            font-size: 18px; /* Larger number */
            font-weight: bold;
            text-align: center;
            padding: 2px;
            box-sizing: border-box;
            position: relative; /* For potential absolute positioning of suit symbols */
        }
        .tile span { /* For the small suit letter */
            font-size: 0.6em;
            font-weight: normal;
            position: absolute;
            bottom: 2px;
            right: 4px;
        }
        .tile.joker { background-color: #e6e6fa; color: #551a8b; } /* Lavender */
        .tile.flower { background-color: #fffacd; color: #ff4500; } /* Lemon chiffon */
        .tile.wind { background-color: #add8e6; color: #00008b; } /* Light blue */
        .tile.dragon { background-color: #90ee90; color: #006400; } /* Default Light green for dragons */
        .tile.dragon-rd { background-color: #ffcccb; color: #dc143c; } /* Light Red background, Crimson text for Red Dragon */
        .tile.dragon-gd { background-color: #90ee90; color: #006400; } /* Explicit Light Green for Green Dragon */
        .tile.dragon-wd { background-color: #f8f8ff; color: #404040; } /* Ghost White background, Dark Gray text for White Dragon */
        .tile.bam { color: #006400; } /* Dark Green for Bamboo */
        .tile.crack { color: #dc143c; } /* Crimson for Characters */
        .tile.dot { color: #00008b; } /* Dark Blue for Dots */
    </style>
</head>
<body>
<h2>Mahjong Hand Analyzer (Simple)</h2>
<button id="generateBtn">Generate Random Hand</button>
<button id="analyzeBtn">Analyze Hand</button>
<button id="sortSuitBtn">Sort by Suit</button>
<button id="sortNumBtn">Sort by Number</button>
<div id="handDisplay">(No hand yet)</div>
<div id="analysisSummaryDisplay"></div>
<pre id="resultDisplay">(No analysis yet)</pre>
<script>
// --- Tile Set (simplified, update as needed) ---
const TILES = [
    ...Array.from({length: 9}, (_,i) => `${i+1}bam`),
    ...Array.from({length: 9}, (_,i) => `${i+1}crack`),
    ...Array.from({length: 9}, (_,i) => `${i+1}dot`),
    'rd','gd','wd', // Dragons
    'e','s','w','n', // Winds
    'F','F','F','F' // Flowers (all are 'F' as they are interchangeable)
];

// --- Random Hand Generator ---
function generateRandomHand(size=14) {
    const pool = [...TILES, ...TILES, ...TILES, ...TILES]; // 4 of each tile
    for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    return pool.slice(0, size);
}

// --- Hand Analysis Logic (real) ---

// Helper: Base class for hand templates
class HandTemplate {
    constructor(config) {
        this.templateId = config.templateId;
        this.name = config.name;
        this.description = config.description;
        this.category = config.category;
        this.pointValue = config.pointValue || 1;
        this.number = config.number || null;
    }
    generateVariations() {
        throw new Error('Subclasses must implement generateVariations');
    }
    validateHand(tiles) {
        throw new Error('Subclasses must implement validateHand');
    }
}

// --- Template 1: SequenceAndKongsTemplate ---
class SequenceAndKongsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'sequence_and_kongs',
            name: 'Sequence and Kongs',
            description: 'Pair of the starting number, sequence of 5 in one suit (starting with the pair), and kongs of the starting number in the other two suits',
            category: 'Sequences',
            pointValue: 30,
            number: 1
        });
    }
    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot'];
        for (const seqSuit of SUITS) {
            for (let startNum = 1; startNum <= 5; startNum++) {
                const variation = [];
                let groupIndex = 0;
                // Pair of the starting number in the sequence suit
                for (let i = 0; i < 2; i++) {
                    const tileCode = `${startNum}${seqSuit}`;
                    variation.push({
                        type: 'pair', tile: tileCode, value: tileCode, groupIndex, position: i
                    });
                }
                groupIndex++;
                // Sequence of 4 more tiles (to make a 5-tile sequence with the pair)
                for (let i = 1; i < 5; i++) {
                    const tileCode = `${startNum + i}${seqSuit}`;
                    variation.push({
                        type: 'sequence', tile: tileCode, value: tileCode, groupIndex, position: i
                    });
                }
                groupIndex++;
                // Two kongs of the starting number in the other two suits
                let kongsAdded = 0;
                for (const kongSuit of SUITS) {
                    if (kongSuit !== seqSuit && kongsAdded < 2) {
                        for (let i = 0; i < 4; i++) {
                            const tileCode = `${startNum}${kongSuit}`;
                            variation.push({
                                type: 'kong', tile: tileCode, value: tileCode, groupIndex, position: i
                            });
                        }
                        groupIndex++;
                        kongsAdded++;
                    }
                }
                variations.push({
                    name: `Pair ${startNum}${seqSuit}, sequence ${startNum}-${startNum+4}${seqSuit}, kongs of ${startNum} in other suits`,
                    slots: variation
                });
            }
        }
        return variations;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 2: Symmetrical13579AllSuitsTemplate ---
class Symmetrical13579AllSuitsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'symmetrical_13579_all_suits',
            name: '13579 Symmetrical - All 3 suits',
            description: 'Pair of 1s (suit1), Pung of 3s (suit1), Kong of 5s (suit2), Pung of 7s (suit3), Pair of 9s (suit3).',
            category: '13579',
            pointValue: 25,
            number: 2
        });
    }

    _createTileGroup(tileCode, count, type, groupIndex) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type: type,
                tile: tileCode,
                value: tileCode, 
                groupIndex: groupIndex,
                position: i
            });
        }
        return group;
    }

    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot'];

        for (const suit1 of SUITS) {
            for (const suit2 of SUITS) {
                if (suit1 === suit2) continue;
                for (const suit3 of SUITS) {
                    if (suit3 === suit1 || suit3 === suit2) continue;

                    const variation = [];
                    let groupIndex = 0;

                    // Pair - 1, suit1
                    variation.push(...this._createTileGroup(`1${suit1}`, 2, 'pair', groupIndex++));
                    // Pung - 3, suit1
                    variation.push(...this._createTileGroup(`3${suit1}`, 3, 'pung', groupIndex++));
                    // Kong - 5, suit2
                    variation.push(...this._createTileGroup(`5${suit2}`, 4, 'kong', groupIndex++));
                    // Pung - 7, suit3
                    variation.push(...this._createTileGroup(`7${suit3}`, 3, 'pung', groupIndex++));
                    // Pair - 9, suit3
                    variation.push(...this._createTileGroup(`9${suit3}`, 2, 'pair', groupIndex++));
                    
                    variations.push({
                        name: `13579 Sym: S1=${suit1}, S2=${suit2}, S3=${suit3}`,
                        slots: variation,
                        description: `1s(${suit1}), 3s(${suit1}), 5s(${suit2}), 7s(${suit3}), 9s(${suit3})`
                    });
                }
            }
        }
        return variations;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 3: KongKongPairWithFlowersAndDragonsTemplate ---
class KongKongPairWithFlowersAndDragonsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'kong_kong_pair_flowers_dragons',
            name: 'Kong Kong Pair with Flowers and Dragons',
            description: 'Pair of Flowers, two kongs of the same number in different suits with single dragons, and a pair of the same number in a third suit',
            category: 'Special',
            pointValue: 25,
            number: 1
        });
    }
    generateVariations() {
        const variations = [];
        const ALL_SUITS_ORDERED = ['bam', 'crack', 'dot']; // Fixed order for consistent permutation
        const SUIT_TO_DRAGON_MAP = {
            'bam': 'gd',  // Bam Kong -> Green Dragon
            'crack': 'rd', // Crack Kong -> Red Dragon
            'dot': 'wd'   // Dot Kong -> White Dragon
        };

        for (let number = 1; number <= 9; number++) { // 9 choices for the number component
            // New suit iteration logic to achieve 3 permutations for (kongSuit1, kongSuit2, pairSuit)
            for (let pairSuitIndex = 0; pairSuitIndex < ALL_SUITS_ORDERED.length; pairSuitIndex++) {
                const pairSuit = ALL_SUITS_ORDERED[pairSuitIndex];
                const otherSuitsForKongs = ALL_SUITS_ORDERED.filter(s => s !== pairSuit);
                const kongSuit1 = otherSuitsForKongs[0]; // First of the remaining suits for the first kong
                const kongSuit2 = otherSuitsForKongs[1]; // Second of the remaining suits for the second kong

                const dragonForKong1 = SUIT_TO_DRAGON_MAP[kongSuit1];
                const dragonForKong2 = SUIT_TO_DRAGON_MAP[kongSuit2];

                const currentVariationSlots = [];
                let groupIndex = 0;

                // Pair of generic Flowers (2 tiles)
                currentVariationSlots.push(...this._createTileGroup('F', 2, 'pair', groupIndex++, true));
                
                // Kong of 'number' in kongSuit1 (4 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${number}${kongSuit1}`, 4, 'kong', groupIndex++));
                
                // Kong of 'number' in kongSuit2 (4 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${number}${kongSuit2}`, 4, 'kong', groupIndex++));
                
                // Pair of 'number' in pairSuit (2 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${number}${pairSuit}`, 2, 'pair', groupIndex++));

                // Single Dragon corresponding to kongSuit1 (1 tile)
                currentVariationSlots.push(...this._createTileGroup(dragonForKong1, 1, 'single', groupIndex++));
                // Single Dragon corresponding to kongSuit2 (1 tile)
                currentVariationSlots.push(...this._createTileGroup(dragonForKong2, 1, 'single', groupIndex++));
                
                // Total tiles: 2 (F) + 4 (K1) + 4 (K2) + 2 (P) + 1 (D1) + 1 (D2) = 14 tiles
                if (currentVariationSlots.length === 14) {
                    variations.push({
                        name: `Kongs of ${number} (${kongSuit1[0].toUpperCase()}/${kongSuit2[0].toUpperCase()}), Pair ${number} (${pairSuit[0].toUpperCase()}), Flowers, Dragons (${dragonForKong1}/${dragonForKong2})`,
                        slots: currentVariationSlots,
                        description: `Pair of flowers, kongs of ${number}${kongSuit1} and ${number}${kongSuit2}, pair of ${number}${pairSuit}, and single ${dragonForKong1} & ${dragonForKong2} dragons.`
                    });
                }
            }
        }
        return variations;
    }
    _createTileGroup(tileCode, count, type, groupIndex, isFlower = false) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type, value: tileCode, tile: tileCode, groupIndex, position: i, isFlower
            });
        }
        return group;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 4: EvenChowEvenPungsFlowersTemplate ---
class EvenChowEvenPungsFlowersTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'even_chow_even_pungs_flowers',
            name: 'Even Chow + Even Pungs + Flowers',
            description: 'Kong of Flowers, singles of 2,4,6,8 in one suit, and pungs of the same even number in the other two suits',
            category: 'Even Numbers',
            pointValue: 35,
            number: 4
        });
    }
    generateVariations() {
        const variations = [];
        const evenNumbers = [2, 4, 6, 8];
        const ALL_SUITS_ORDERED = ['bam', 'crack', 'dot']; // Use a fixed order for consistent permutation

        for (const evenNum of evenNumbers) { // 4 choices for the even number of the pungs
            // New suit iteration logic to get 3 permutations
            for (const chowSuit of ALL_SUITS_ORDERED) {
                const otherSuits = ALL_SUITS_ORDERED.filter(s => s !== chowSuit);
                const pungSuit1 = otherSuits[0]; // First of the remaining suits
                const pungSuit2 = otherSuits[1]; // Second of the remaining suits

                const currentVariationSlots = [];
                let groupIndex = 0;

                // Kong of generic Flowers (4 tiles)
                currentVariationSlots.push(...this._createTileGroup('F', 4, 'kong', groupIndex++));
                
                // Singles of 2,4,6,8 in chowSuit (4 tiles)
                for (const num of evenNumbers) {
                    currentVariationSlots.push(...this._createTileGroup(`${num}${chowSuit}`, 1, 'single', groupIndex++, 1));
                }
                
                // Pung of 'evenNum' in pungSuit1 (3 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${evenNum}${pungSuit1}`, 3, 'pung', groupIndex++));
                
                // Pung of 'evenNum' in pungSuit2 (3 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${evenNum}${pungSuit2}`, 3, 'pung', groupIndex++));

                // Total tiles: 4 (flowers) + 4 (singles) + 3 (pung1) + 3 (pung2) = 14 tiles
                if (currentVariationSlots.length === 14) {
                    variations.push({
                        name: `Even ${evenNum} - ${chowSuit} singles, ${pungSuit1}/${pungSuit2} pungs`,
                        slots: currentVariationSlots,
                        description: `Kong of Flowers, singles of 2,4,6,8 in ${chowSuit}, pungs of ${evenNum} in ${pungSuit1} and ${pungSuit2}`
                    });
                }
            }
        }
        return variations;
    }
    _createTileGroup(tileCode, count, type, groupIndex, position = 0) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type, tile: tileCode, value: tileCode, groupIndex, position: position === 0 ? i : position
            });
        }
        return group;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- TileMatcher ---
class TileMatcher {
    constructor() { this.reset(); }
    reset() {
        this.hand = [];
        this.variation = [];
        this.availableJokers = 0;
        this.usedJokers = 0;
        this.matchedTiles = [];
        this.variationCopy = [];
    }
    matchVariation(hand, variation, availableJokers = 0) {
        this.reset();
        this.hand = [...hand];
        this.variation = variation.slots || variation;
        this.availableJokers = availableJokers;
        this.variationCopy = JSON.parse(JSON.stringify(this.variation));

        // First pass: try to match exact tiles
        this.matchExactTiles();
        // Second pass: use jokers to fill remaining slots in valid groups
        this.matchWithJokers();
        const score = this.calculateScore();
        const maxPossibleScore = this.variation.length;
        const resultToReturn = {
            score,
            maxPossibleScore,
            matchedTiles: [...this.matchedTiles],
            matchedTilesCount: this.matchedTiles.length, // Ensure this is returned for summary
            usedJokers: this.usedJokers,
            variation: this.variationCopy
        };
        return resultToReturn;
    }
    matchExactTiles() {
        const handCopy = [...this.hand];
        for (let i = 0; i < handCopy.length; i++) {
            const tile = handCopy[i];
            if (tile === undefined || tile === null) continue;
            let matched = false;
            for (let j = 0; j < this.variation.length; j++) {
                const slot = this.variation[j];
                if (slot.matched) continue;
                if (!slot || slot.tile === undefined) continue;
                if (this.tilesMatch(tile, slot.tile)) {
                    slot.matched = true;
                    slot.usedJoker = false;
                    this.matchedTiles.push(tile);
                    handCopy.splice(i, 1);
                    i--;
                    matched = true;
                    break;
                }
            }
        }
        this.hand = handCopy;
    }
    matchWithJokers() {
        // Only use jokers if we have some available
        if (this.availableJokers <= 0) return;
        // Find all unmatched slots that are part of a valid group
        // (For simplicity, just fill unmatched slots with jokers)
        for (let j = 0; j < this.variation.length && this.availableJokers > 0; j++) {
            const slot = this.variation[j];
            if (!slot.matched) {
                slot.matched = true;
                slot.usedJoker = true;
                this.matchedTiles.push('joker');
                this.usedJokers++;
                this.availableJokers--;
            }
        }
    }
    calculateScore() {
        // Score: number of matched slots (excluding jokers)
        return this.matchedTiles.filter(t => t !== 'joker').length;
    }
    tilesMatch(tileA, tileB) {
        // Case-insensitive match
        return (tileA || '').toLowerCase() === (tileB || '').toLowerCase();
    }
}

// --- HandAnalyzer ---
class HandAnalyzer {
    constructor() {
        this.templates = [];
        this.tileMatcher = new TileMatcher();
        this.initializeTemplates();
    }
    initializeTemplates() {
        this.templates.push(new SequenceAndKongsTemplate());
        this.templates.push(new Symmetrical13579AllSuitsTemplate());
        this.templates.push(new KongKongPairWithFlowersAndDragonsTemplate());
        this.templates.push(new EvenChowEvenPungsFlowersTemplate());
    }
    analyzeHand(hand) {
        if (!hand || hand.length === 0) {
            return [];
        }
        const nonJokerTiles = hand.filter(tile => !tile.startsWith('j'));
        const jokers = hand.length - nonJokerTiles.length;
        const results = [];
        this.templates.forEach(template => {
            const { bestOverallMatch, maxMatchedTilesCount, countMaxTilesVariations, topTierMatchResults, totalGeneratedVariations } = this.analyzeTemplate(template, nonJokerTiles, jokers);

            if (bestOverallMatch) { // A best overall match (by score) was found
                results.push({
                    templateId: template.templateId,
                    templateName: template.name,
                    category: template.category,
                    pointValue: template.pointValue,
                    ...bestOverallMatch, // Spread details of the highest scoring match for detailed view
                    summaryMatchedTiles: maxMatchedTilesCount, // 't' for summary
                    summaryVariationCount: countMaxTilesVariations, // 'v' for summary
                    topTierMatchResults: topTierMatchResults, // Array of match results for highlighting
                    summaryTotalVariations: totalGeneratedVariations // Total variations for this template
                });
            }
        });
        results.sort((a, b) => b.score - a.score);
        return results;
    }
    analyzeTemplate(template, nonJokerTiles, availableJokers) {
        let bestOverallMatch = null;
        let maxMatchedTilesCount = -1;
        const allMatchResults = []; // This will store results from the first loop
        const topTierMatchResults = []; // Stores matchResults for variations achieving maxMatchedTilesCount

        const variations = template.generateVariations();
        const totalGeneratedVariations = variations ? variations.length : 0;

        if (!variations || variations.length === 0) {
            return { bestOverallMatch: null, maxMatchedTilesCount: 0, countMaxTilesVariations: 0, topTierMatchResults: [], totalGeneratedVariations: 0 };
        }

        // 1st loop: find maxMatchedTilesCount and bestOverallMatch
        for (let i = 0; i < variations.length; i++) {
            const variation = variations[i];
            const matchResult = this.tileMatcher.matchVariation(nonJokerTiles, variation, availableJokers);
            allMatchResults.push(matchResult);

            if (!bestOverallMatch || matchResult.score > bestOverallMatch.score) {
                bestOverallMatch = matchResult;
            }

            if (matchResult.matchedTilesCount > maxMatchedTilesCount) {
                maxMatchedTilesCount = matchResult.matchedTilesCount;
            }
        }

        // 2nd loop: collect variations achieving maxMatchedTilesCount
        if (maxMatchedTilesCount > -1 && allMatchResults.length > 0) {
            for (let i = 0; i < allMatchResults.length; i++) {
                const res = allMatchResults[i];
                if (res.matchedTilesCount === maxMatchedTilesCount) {
                    topTierMatchResults.push(res);
                }
            }
        }
        const countMaxTilesVariations = topTierMatchResults.length;
        return { bestOverallMatch, maxMatchedTilesCount, countMaxTilesVariations, topTierMatchResults, totalGeneratedVariations };
    }
}
const handAnalyzer = new HandAnalyzer();

// --- Highlighting Logic ---
function updateHandHighlighting(naturalTilesToHighlight, usedJokersCount) {
    const handDisplay = document.getElementById('handDisplay');
    const displayedTileElements = Array.from(handDisplay.children);

    // 1. Clear all existing highlights
    displayedTileElements.forEach(tileEl => tileEl.classList.remove('tile-highlighted'));

    if (!naturalTilesToHighlight && usedJokersCount === 0) return; // Nothing to highlight

    const tilesToHighlightCopy = naturalTilesToHighlight ? [...naturalTilesToHighlight] : [];
    let jokersToHighlight = usedJokersCount || 0;

    // 2. Highlight natural tiles
    // Iterate through displayed tiles. If a tile matches one in tilesToHighlightCopy, highlight it and remove from copy.
    for (const tileEl of displayedTileElements) {
        if (tileEl.dataset.code.startsWith('j')) continue; // Skip jokers for now

        const indexInCopyToHighlight = tilesToHighlightCopy.indexOf(tileEl.dataset.code);
        if (indexInCopyToHighlight !== -1) {
            tileEl.classList.add('tile-highlighted');
            tilesToHighlightCopy.splice(indexInCopyToHighlight, 1); // Remove highlighted tile from copy
        }
    }

    // 3. Highlight jokers
    // Iterate through displayed joker tiles and highlight the required number.
    for (const tileEl of displayedTileElements) {
        if (jokersToHighlight === 0) break; // All required jokers highlighted
        if (tileEl.dataset.code.startsWith('j')) {
            tileEl.classList.add('tile-highlighted');
            jokersToHighlight--;
        }
    }
}

// --- UI Interaction ---
function createTileElement(tileCode) {
    if (!tileCode) return null;

    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.dataset.code = tileCode; // Store original code for debugging/sorting
    // ... rest of your code remains the same ...

    let suit = '', value = '';

    if (tileCode.startsWith('j')) { // Joker
        tile.textContent = 'JOK'; // Short for Joker
        tile.classList.add('joker');
        suit = 'JOKER';
        value = tileCode; // e.g., j1
    } else if (tileCode === 'F') { // Flower
        tile.textContent = 'FLR'; // Short for Flower
        tile.classList.add('flower');
        suit = 'FLOWER';
        value = 'F';
    } else if (['e', 's', 'w', 'n'].includes(tileCode.toLowerCase())) { // Winds
        tile.textContent = tileCode.toUpperCase();
        tile.classList.add('wind');
        suit = 'WIND';
        value = tileCode;
    } else if (['rd', 'gd', 'wd'].includes(tileCode.toLowerCase())) { // Dragons
        tile.textContent = tileCode.toUpperCase();
        tile.classList.add('dragon');
        if (tileCode.toLowerCase() === 'rd') tile.classList.add('dragon-rd');
        else if (tileCode.toLowerCase() === 'gd') tile.classList.add('dragon-gd');
        else if (tileCode.toLowerCase() === 'wd') tile.classList.add('dragon-wd');
        suit = 'DRAGON';
        value = tileCode;
    } else { // Suited tiles: 1bam, 5dot, 9crack etc.
        const match = tileCode.match(/^(\d+)([a-z]+)$/);
        if (match) {
            const num = match[1];
            const suitName = match[2];
            tile.textContent = num; // Display the number
            const suitSpan = document.createElement('span');
            // suitSpan.style.fontSize = '0.7em'; // Handled by .tile span CSS
            // suitSpan.style.display = 'block';
            suitSpan.textContent = suitName.substring(0,1).toUpperCase(); // B, C, D
            tile.appendChild(suitSpan);

            tile.classList.add(suitName); // e.g., 'bam', 'crack', 'dot' for specific styling
            suit = suitName.toUpperCase();
            value = num;
        } else {
            tile.textContent = tileCode; // Fallback for unknown
        }
    }
    tile.dataset.suit = suit;
    tile.dataset.value = value; // Store parsed value for sorting

    return tile;
}

const SUIT_ORDER = { BAM: 1, CRACK: 2, DOT: 3, WIND: 4, DRAGON: 5, FLOWER: 6, JOKER: 7 };
const WIND_ORDER = { e: 1, s: 2, w: 3, n: 4 };
const DRAGON_ORDER = { rd: 1, gd: 2, wd: 3 };

function getTileSortableValues(tileCode) {
    let suit, valueNum, suitOrder, valueOrder;

    if (tileCode.startsWith('j')) {
        suit = 'JOKER';
        valueNum = parseInt(tileCode.substring(1)) || 0;
    } else if (tileCode === 'F') {
        suit = 'FLOWER';
        valueNum = 1;
    } else if (['e', 's', 'w', 'n'].includes(tileCode.toLowerCase())) {
        suit = 'WIND';
        valueNum = WIND_ORDER[tileCode.toLowerCase()];
    } else if (['rd', 'gd', 'wd'].includes(tileCode.toLowerCase())) {
        suit = 'DRAGON';
        valueNum = DRAGON_ORDER[tileCode.toLowerCase()];
    } else {
        const match = tileCode.match(/^(\d+)([a-z]+)$/);
        if (match) {
            valueNum = parseInt(match[1]);
            suit = match[2].toUpperCase();
        } else {
            suit = 'UNKNOWN'; valueNum = 99;
        }
    }
    suitOrder = SUIT_ORDER[suit] || 99;
    valueOrder = valueNum;
    return { suit, valueNum, suitOrder, valueOrder };
}

function sortHand(handArray, sortBySuitPrimary = true) {
    handArray.sort((a, b) => {
        const valA = getTileSortableValues(a);
        const valB = getTileSortableValues(b);

        if (sortBySuitPrimary) {
            if (valA.suitOrder !== valB.suitOrder) {
                return valA.suitOrder - valB.suitOrder;
            }
            return valA.valueOrder - valB.valueOrder;
        } else { // Sort by Number (value) first
            if (valA.valueOrder !== valB.valueOrder) {
                return valA.valueOrder - valB.valueOrder;
            }
            return valA.suitOrder - valB.suitOrder;
        }
    });
}

function renderHand(handArray, displayElement) {
    displayElement.innerHTML = ''; // Clear previous display
    if (!handArray || handArray.length === 0) {
        displayElement.textContent = '(No hand yet)';
        return;
    }
    handArray.forEach(tileCode => {
        const tileEl = createTileElement(tileCode);
        if (tileEl) {
            displayElement.appendChild(tileEl);
        }
    });
}

// --- UI Logic ---
let currentHand = [];
const handDisplay = document.getElementById('handDisplay');
const resultDisplay = document.getElementById('resultDisplay');

document.getElementById('generateBtn').onclick = function() {
    currentHand = generateRandomHand();
    renderHand(currentHand, handDisplay);
    resultDisplay.textContent = '(No analysis yet)';
    const summaryDisplayElement = document.getElementById('analysisSummaryDisplay');
    if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear summary display
};
document.getElementById('analyzeBtn').onclick = function() {
    const detailedResultDisplay = document.getElementById('resultDisplay');
    const summaryDisplayElement = document.getElementById('analysisSummaryDisplay'); // Get reference

    if (!currentHand || currentHand.length === 0) { // More robust check
        if(detailedResultDisplay) detailedResultDisplay.textContent = '(Generate a hand first)';
        if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear summary display as well
        return;
    }
    const analysisResultsArray = handAnalyzer.analyzeHand(currentHand);

    // Populate Summary Display
    if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear previous summary
    if (analysisResultsArray && analysisResultsArray.length > 0) {
        analysisResultsArray.forEach(templateAnalysis => {
            const row = document.createElement('div');
            row.className = 'summary-row';
            row.dataset.templateId = templateAnalysis.templateId; // For future click functionality
            
            // Store the detailed match results for highlighting and initialize variation index
            row.topTierMatchResults = templateAnalysis.topTierMatchResults || []; // Ensure it's an array
            row.dataset.currentVariationIndex = -1; // Initialize for cycling through variations

            const mainText = `${templateAnalysis.templateName} tiles=${templateAnalysis.summaryMatchedTiles} vars=${templateAnalysis.summaryVariationCount} totvars=${templateAnalysis.summaryTotalVariations}`;
            
            const variationDisplaySpan = document.createElement('span');
            variationDisplaySpan.className = 'variation-display';
            // This span will be updated on click to show e.g., "(Variation 1 of 3)"

            row.innerHTML = mainText + ' ';
            row.appendChild(variationDisplaySpan);
            
            if (summaryDisplayElement) summaryDisplayElement.appendChild(row);
        });
    } else {
        if (summaryDisplayElement) summaryDisplayElement.textContent = '(No analysis summary available)';
    }

    // Populate Detailed JSON Display
    const jsonString = JSON.stringify(analysisResultsArray, null, 2);
    detailedResultDisplay.textContent = jsonString;

    // Add click listener for summary rows to handle highlighting
    if (summaryDisplayElement) {
        summaryDisplayElement.removeEventListener('click', handleSummaryRowClick); // Remove old listener if any
        summaryDisplayElement.addEventListener('click', handleSummaryRowClick);
    }
};

function handleSummaryRowClick(event) {
    const clickedRow = event.target.closest('.summary-row');
    if (!clickedRow) return;

    const topMatches = clickedRow.topTierMatchResults;
    if (!topMatches || topMatches.length === 0) {
        updateHandHighlighting([], 0); // Clear highlights if no variations
        const variationDisplay = clickedRow.querySelector('.variation-display');
        if (variationDisplay) variationDisplay.textContent = '';
        return;
    }

    let currentIndex = parseInt(clickedRow.dataset.currentVariationIndex, 10);
    currentIndex++;
    if (currentIndex >= topMatches.length) {
        currentIndex = 0;
    }
    clickedRow.dataset.currentVariationIndex = currentIndex;

    const currentMatch = topMatches[currentIndex];
    updateHandHighlighting(currentMatch.matchedTiles, currentMatch.usedJokers);

    const variationDisplay = clickedRow.querySelector('.variation-display');
    if (variationDisplay) {
        if (topMatches.length > 0) {
            variationDisplay.textContent = `(Variation ${currentIndex + 1} of ${topMatches.length})`;
        } else {
            variationDisplay.textContent = '';
        }
    }
}

document.getElementById('sortSuitBtn').onclick = function() {
    if (!currentHand.length) return;
    sortHand(currentHand, true); // true for sortBySuitPrimary
    renderHand(currentHand, handDisplay);
};

document.getElementById('sortNumBtn').onclick = function() {
    if (!currentHand.length) return;
    sortHand(currentHand, false); // false for sortBySuitPrimary (so sort by number first)
    renderHand(currentHand, handDisplay);
};
</script>
</body>
</html>
