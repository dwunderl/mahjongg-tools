<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mahjong Hand Analyzer (Simple)</title>
    <style>
        body { font-family: sans-serif; max-width: 600px; margin: 2em auto; }
        button { margin: 0.5em 0.5em 0.5em 0; padding: 0.5em 1.2em; font-size: 1em; }
        #handDisplay { font-size: 1.1em; margin: 1em 0; background: #f8f8f8; padding: 0.5em; border-radius: 4px; min-width: 690px; white-space: nowrap; overflow-x: auto; }
        pre { background: #f3f3f3; padding: 1em; border-radius: 4px; }
        #analysisSummaryDisplay {
            background: #e8f0fe; /* Light blue background */
            padding: 0.5em;
            border-radius: 4px;
            margin-bottom: 1em; /* Space before detailed JSON results */
            border: 1px solid #cddcec;
        }
        .summary-row {
            padding: 0.25em 0.5em;
            font-family: monospace;
            border-bottom: 1px dashed #d0d8e0;
        }
        .summary-row:last-child {
            border-bottom: none;
        }
        .summary-row .variation-display {
            font-style: italic;
            font-size: 0.9em;
            color: #555;
            margin-left: 10px;
        }
        .tile-highlighted {
            border: 3px solid gold !important; /* !important to ensure override */
            box-shadow: 0 0 10px gold;
            transform: scale(1.05); /* Slightly enlarge highlighted tiles */
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .tile {
            width: 45px; /* Adjusted for better fit */
            height: 65px; /* Adjusted for better fit */
            border: 1px solid #999;
            border-radius: 4px;
            background-color: #fff9f0; /* Light cream */
            margin: 2px;
            display: inline-flex; /* For horizontal layout */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none;
            font-size: 18px; /* Larger number */
            font-weight: bold;
            text-align: center;
            padding: 2px;
            box-sizing: border-box;
            position: relative; /* For potential absolute positioning of suit symbols */
        }
        .tile span { /* For the small suit letter */
            font-size: 0.6em;
            font-weight: normal;
            position: absolute;
            bottom: 2px;
            right: 4px;
        }
        .tile.joker { background-color: #e6e6fa; color: #551a8b; } /* Lavender */
        .tile.flower { background-color: #fffacd; color: #ff4500; } /* Lemon chiffon */
        .tile.wind { background-color: #add8e6; color: #00008b; } /* Light blue */
        .tile.dragon { background-color: #90ee90; color: #006400; } /* Default Light green for dragons */
        .tile.dragon-rd { background-color: #ffcccb; color: #dc143c; } /* Light Red background, Crimson text for Red Dragon */
        .tile.dragon-gd { background-color: #90ee90; color: #006400; } /* Explicit Light Green for Green Dragon */
        .tile.dragon-wd { background-color: #f8f8ff; color: #404040; } /* Ghost White background, Dark Gray text for White Dragon */
        .tile.bam { color: #006400; } /* Dark Green for Bamboo */
        .tile.crack { color: #dc143c; } /* Crimson for Characters */
        .tile.dot { color: #00008b; } /* Dark Blue for Dots */
    </style>
</head>
<body>
<h2>Mahjong Hand Analyzer (Simple)</h2>
<button id="generateBtn">Generate Random Hand</button>
<button id="analyzeBtn">Analyze Hand</button>
<button id="sortSuitBtn">Sort by Suit</button>
<button id="sortNumBtn">Sort by Number</button>
<div id="handDisplay">(No hand yet)</div>
<div id="analysisSummaryDisplay"></div>
<pre id="resultDisplay">(No analysis yet)</pre>
<script>
// --- Tile Set (simplified, update as needed) ---
const TILES = [
    ...Array.from({length: 9}, (_,i) => `${i+1}bam`),
    ...Array.from({length: 9}, (_,i) => `${i+1}crack`),
    ...Array.from({length: 9}, (_,i) => `${i+1}dot`),
    'rd','gd','wd', // Dragons
    'e','s','w','n', // Winds
    'F','F','F','F', // Flowers (all are 'F' as they are interchangeable)
    'J','J','J','J'  // Jokers (all are 'J' as they are completely interchangeable)
];

// --- Random Hand Generator ---
function generateRandomHand(size=14) {
    const pool = [...TILES, ...TILES, ...TILES, ...TILES]; // 4 of each tile
    for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    return pool.slice(0, size);
}

// --- Hand Analysis Logic (real) ---

// Helper: Base class for hand templates
class HandTemplate {
    constructor(config) {
        this.templateId = config.templateId;
        this.name = config.name;
        this.description = config.description;
        this.category = config.category;
        this.pointValue = config.pointValue || 1;
        this.number = config.number || null;
    }
    generateVariations() {
        throw new Error('Subclasses must implement generateVariations');
    }
    validateHand(tiles) {
        throw new Error('Subclasses must implement validateHand');
    }
}

// --- Template 1: SequenceAndKongsTemplate ---
class SequenceAndKongsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'sequence_and_kongs',
            name: 'Sequence and Kongs',
            description: 'Pair of the starting number, sequence of 5 in one suit (starting with the pair), and kongs of the starting number in the other two suits',
            category: 'Sequences',
            pointValue: 30,
            number: 1
        });
    }
    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot'];
        for (const seqSuit of SUITS) {
            for (let startNum = 1; startNum <= 5; startNum++) {
                const variation = [];
                let groupIndex = 0;
                // Pair of the starting number in the sequence suit
                for (let i = 0; i < 2; i++) {
                    const tileCode = `${startNum}${seqSuit}`;
                    variation.push({
                        type: 'pair', tile: tileCode, value: tileCode, groupIndex, position: i
                    });
                }
                groupIndex++;
                // Sequence of 4 more tiles (to make a 5-tile sequence with the pair)
                for (let i = 1; i < 5; i++) {
                    const tileCode = `${startNum + i}${seqSuit}`;
                    variation.push({
                        type: 'sequence', tile: tileCode, value: tileCode, groupIndex, position: i
                    });
                }
                groupIndex++;
                // Two kongs of the starting number in the other two suits
                let kongsAdded = 0;
                for (const kongSuit of SUITS) {
                    if (kongSuit !== seqSuit && kongsAdded < 2) {
                        for (let i = 0; i < 4; i++) {
                            const tileCode = `${startNum}${kongSuit}`;
                            variation.push({
                                type: 'kong', tile: tileCode, value: tileCode, groupIndex, position: i
                            });
                        }
                        groupIndex++;
                        kongsAdded++;
                    }
                }
                variations.push({
                    name: `Pair ${startNum}${seqSuit}, sequence ${startNum}-${startNum+4}${seqSuit}, kongs of ${startNum} in other suits`,
                    slots: variation
                });
            }
        }
        return variations;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 2: Symmetrical13579AllSuitsTemplate ---
class Symmetrical13579AllSuitsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'symmetrical_13579_all_suits',
            name: '13579 Symmetrical - All 3 suits',
            description: 'Pair of 1s (suit1), Pung of 3s (suit1), Kong of 5s (suit2), Pung of 7s (suit3), Pair of 9s (suit3).',
            category: '13579',
            pointValue: 25,
            number: 2
        });
    }

    _createTileGroup(tileCode, count, type, groupIndex) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type: type,
                tile: tileCode,
                value: tileCode, 
                groupIndex: groupIndex,
                position: i
            });
        }
        return group;
    }

    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot'];

        for (const suit1 of SUITS) {
            for (const suit2 of SUITS) {
                if (suit1 === suit2) continue;
                for (const suit3 of SUITS) {
                    if (suit3 === suit1 || suit3 === suit2) continue;

                    const variation = [];
                    let groupIndex = 0;

                    // Pair - 1, suit1
                    variation.push(...this._createTileGroup(`1${suit1}`, 2, 'pair', groupIndex++));
                    // Pung - 3, suit1
                    variation.push(...this._createTileGroup(`3${suit1}`, 3, 'pung', groupIndex++));
                    // Kong - 5, suit2
                    variation.push(...this._createTileGroup(`5${suit2}`, 4, 'kong', groupIndex++));
                    // Pung - 7, suit3
                    variation.push(...this._createTileGroup(`7${suit3}`, 3, 'pung', groupIndex++));
                    // Pair - 9, suit3
                    variation.push(...this._createTileGroup(`9${suit3}`, 2, 'pair', groupIndex++));
                    
                    variations.push({
                        name: `13579 Sym: S1=${suit1}, S2=${suit2}, S3=${suit3}`,
                        slots: variation,
                        description: `1s(${suit1}), 3s(${suit1}), 5s(${suit2}), 7s(${suit3}), 9s(${suit3})`
                    });
                }
            }
        }
        return variations;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 3: KongKongPairWithFlowersAndDragonsTemplate ---
class KongKongPairWithFlowersAndDragonsTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'kong_kong_pair_flowers_dragons',
            name: 'Kong Kong Pair with Flowers and Dragons',
            description: 'Pair of Flowers, two kongs of the same number in different suits with single dragons, and a pair of the same number in a third suit',
            category: 'Special',
            pointValue: 25,
            number: 1
        });
    }
    generateVariations() {
        const variations = [];
        const ALL_SUITS_ORDERED = ['bam', 'crack', 'dot']; // Fixed order for consistent permutation
        const SUIT_TO_DRAGON_MAP = {
            'bam': 'gd',  // Bam Kong -> Green Dragon
            'crack': 'rd', // Crack Kong -> Red Dragon
            'dot': 'wd'   // Dot Kong -> White Dragon
        };

        for (let number = 1; number <= 9; number++) { // 9 choices for the number component
            // New suit iteration logic to achieve 3 permutations for (kongSuit1, kongSuit2, pairSuit)
            for (let pairSuitIndex = 0; pairSuitIndex < ALL_SUITS_ORDERED.length; pairSuitIndex++) {
                const pairSuit = ALL_SUITS_ORDERED[pairSuitIndex];
                const otherSuitsForKongs = ALL_SUITS_ORDERED.filter(s => s !== pairSuit);
                const kongSuit1 = otherSuitsForKongs[0]; // First of the remaining suits for the first kong
                const kongSuit2 = otherSuitsForKongs[1]; // Second of the remaining suits for the second kong

                const dragonForKong1 = SUIT_TO_DRAGON_MAP[kongSuit1];
                const dragonForKong2 = SUIT_TO_DRAGON_MAP[kongSuit2];

                const currentVariationSlots = [];
                let groupIndex = 0;

                // Pair of generic Flowers (2 tiles)
                currentVariationSlots.push(...this._createTileGroup('F', 2, 'pair', groupIndex++, true));
                
                // Kong of 'number' in kongSuit1 (4 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${number}${kongSuit1}`, 4, 'kong', groupIndex++));
                
                // Kong of 'number' in kongSuit2 (4 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${number}${kongSuit2}`, 4, 'kong', groupIndex++));
                
                // Pair of 'number' in pairSuit (2 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${number}${pairSuit}`, 2, 'pair', groupIndex++));

                // Single Dragon corresponding to kongSuit1 (1 tile)
                currentVariationSlots.push(...this._createTileGroup(dragonForKong1, 1, 'single', groupIndex++));
                // Single Dragon corresponding to kongSuit2 (1 tile)
                currentVariationSlots.push(...this._createTileGroup(dragonForKong2, 1, 'single', groupIndex++));
                
                // Total tiles: 2 (F) + 4 (K1) + 4 (K2) + 2 (P) + 1 (D1) + 1 (D2) = 14 tiles
                if (currentVariationSlots.length === 14) {
                    variations.push({
                        name: `Kongs of ${number} (${kongSuit1[0].toUpperCase()}/${kongSuit2[0].toUpperCase()}), Pair ${number} (${pairSuit[0].toUpperCase()}), Flowers, Dragons (${dragonForKong1}/${dragonForKong2})`,
                        slots: currentVariationSlots,
                        description: `Pair of flowers, kongs of ${number}${kongSuit1} and ${number}${kongSuit2}, pair of ${number}${pairSuit}, and single ${dragonForKong1} & ${dragonForKong2} dragons.`
                    });
                }
            }
        }
        return variations;
    }
    _createTileGroup(tileCode, count, type, groupIndex, isFlower = false) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type, value: tileCode, tile: tileCode, groupIndex, position: i, isFlower
            });
        }
        return group;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Template 4: EvenChowEvenPungsFlowersTemplate ---
class EvenChowEvenPungsFlowersTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'even_chow_even_pungs_flowers',
            name: 'Even Chow + Even Pungs + Flowers',
            description: 'Kong of Flowers, singles of 2,4,6,8 in one suit, and pungs of the same even number in the other two suits',
            category: 'Even Numbers',
            pointValue: 35,
            number: 4
        });
    }
    generateVariations() {
        const variations = [];
        const evenNumbers = [2, 4, 6, 8];
        const ALL_SUITS_ORDERED = ['bam', 'crack', 'dot']; // Use a fixed order for consistent permutation

        for (const evenNum of evenNumbers) { // 4 choices for the even number of the pungs
            // New suit iteration logic to get 3 permutations
            for (const chowSuit of ALL_SUITS_ORDERED) {
                const otherSuits = ALL_SUITS_ORDERED.filter(s => s !== chowSuit);
                const pungSuit1 = otherSuits[0]; // First of the remaining suits
                const pungSuit2 = otherSuits[1]; // Second of the remaining suits

                const currentVariationSlots = [];
                let groupIndex = 0;

                // Kong of generic Flowers (4 tiles)
                currentVariationSlots.push(...this._createTileGroup('F', 4, 'kong', groupIndex++));
                
                // Singles of 2,4,6,8 in chowSuit (4 tiles)
                for (const num of evenNumbers) {
                    currentVariationSlots.push(...this._createTileGroup(`${num}${chowSuit}`, 1, 'single', groupIndex++, 1));
                }
                
                // Pung of 'evenNum' in pungSuit1 (3 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${evenNum}${pungSuit1}`, 3, 'pung', groupIndex++));
                
                // Pung of 'evenNum' in pungSuit2 (3 tiles)
                currentVariationSlots.push(...this._createTileGroup(`${evenNum}${pungSuit2}`, 3, 'pung', groupIndex++));

                // Total tiles: 4 (flowers) + 4 (singles) + 3 (pung1) + 3 (pung2) = 14 tiles
                if (currentVariationSlots.length === 14) {
                    variations.push({
                        name: `Even ${evenNum} - ${chowSuit} singles, ${pungSuit1}/${pungSuit2} pungs`,
                        slots: currentVariationSlots,
                        description: `Kong of Flowers, singles of 2,4,6,8 in ${chowSuit}, pungs of ${evenNum} in ${pungSuit1} and ${pungSuit2}`
                    });
                }
            }
        }
        return variations;
    }
    _createTileGroup(tileCode, count, type, groupIndex, position = 0) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type, tile: tileCode, value: tileCode, groupIndex, position: position === 0 ? i : position
            });
        }
        return group;
    }
    
    validateHand(tiles) { 
        return { 
            matched: false, 
            score: 0, 
            matchedTiles: [] 
        }; 
    }
}

// --- TileMatcher ---
class TileMatcher {
    constructor() {
        this.reset();
        this.onJokerMatchAttempt = null; // Callback for joker match attempts
        this.jcheck = 0; // Initialize jcheck counter
    }
    
    reset() {
        this.hand = [];
        this.variation = [];
        this.availableJokers = 0;
        this.usedJokers = 0;
        this.matchedTiles = [];
        this.variationCopy = [];
        this.jokerComparisons = 0;
        this.jcheck = 0; // Reset jcheck counter
    }
    
    matchVariation(hand, variation, availableJokers = 0) {
        try {
            this.reset();
            this.hand = [...hand];
            this.variation = Array.isArray(variation) ? variation : (variation.slots || []);
            this.availableJokers = availableJokers;
            this.variationCopy = JSON.parse(JSON.stringify(this.variation));
            
            console.log('\n=== Starting matchVariation ===');
            console.log('Hand:', this.hand);
            console.log('Variation:', this.variation);
            console.log('Available jokers:', this.availableJokers);
            
            // First pass: exact matches (non-joker tiles only)
            console.log('\n--- EXACT MATCHING ---');
            const exactMatch = this.matchExactTiles();
            console.log('After exact matching - hand:', this.hand);
            console.log('Exact matches:', exactMatch.matchedTiles ? exactMatch.matchedTiles.length : 0);
            
            // Extract jokers from remaining hand (case insensitive)
            const jokersInHand = this.hand.filter(t => t.toUpperCase().startsWith('J'));
            const jokersToUse = Math.min(jokersInHand.length, availableJokers);
            const jokersForMatching = jokersInHand.slice(0, jokersToUse);
            
            console.log('\n--- JOKER MATCHING ---');
            console.log('Jokers in hand:', jokersInHand);
            console.log('Jokers available for matching:', jokersToUse);
            
            let jokerMatch = { usedJokers: 0, jokerMatches: [], jokerComparisons: 0 };
            if (jokersForMatching.length > 0) {
                jokerMatch = this.matchWithJokers(jokersForMatching);
                console.log('Joker match results:', jokerMatch);
            } else {
                console.log('No jokers available for matching');
            }
            
            const score = this.calculateScore();
            const maxPossibleScore = this.variationCopy.length;
            
            // Collect all matched tiles
            const matchedTiles = [
                ...(exactMatch.matchedTiles || []).map(m => m.handTile),
                ...(jokerMatch.jokerMatches || []).map(m => m.handTile)
            ];
            
            // Get the jcheck value from the callback if it exists
            const jcheck = typeof this.onJokerMatchAttempt === 'function' ? this.jcheck || 0 : 0;
            
            const result = {
                score,
                maxPossibleScore,
                matchedTiles,
                matchedTilesCount: matchedTiles.length,
                usedJokers: jokerMatch.usedJokers || 0,
                jokerComparisons: jokerMatch.jokerComparisons || 0,
                jcheck: jcheck, // Use the jcheck value from the callback
                variation: this.variationCopy,
                exactMatches: exactMatch.matchedTiles || [],
                jokerMatches: jokerMatch.jokerMatches || []
            };
            
            console.log('\n=== MATCHING COMPLETE ===');
            console.log('Final result:', result);
            
            return result;
            
        } catch (error) {
            console.error('Error in matchVariation:', error);
            return {
                score: 0,
                maxPossibleScore: 0,
                matchedTiles: [],
                matchedTilesCount: 0,
                usedJokers: 0,
                jokerComparisons: 0,
                error: error.message 
            };
        }
    }
    
    matchExactTiles() {
        console.log('=== STARTING EXACT MATCHING ===');
        console.log('Initial hand:', this.hand);
        
        const matchedTiles = [];
        const remainingHand = [];
        
        // First, identify jokers (case insensitive)
        const jokerTiles = this.hand.filter(tile => tile.toUpperCase().startsWith('J'));
        const nonJokerTiles = this.hand.filter(tile => !jokerTiles.includes(tile));
        
        console.log('Non-joker tiles for exact matching:', nonJokerTiles);
        console.log('Jokers found in hand:', jokerTiles);
        
        // First pass: try to match non-joker tiles
        for (const handTile of nonJokerTiles) {
            let matched = false;
            
            for (const variationTile of this.variation) {
                if (variationTile.matched) {
                    continue; // Skip already matched slots
                }
                
                if (this.tilesMatch(handTile, variationTile.tile)) {
                    console.log(`Matched hand tile ${handTile} to variation tile ${variationTile.tile}`);
                    
                    const matchInfo = {
                        handTile,
                        variationTile: variationTile.tile,
                        groupIndex: variationTile.groupIndex,
                        position: variationTile.positionInGroup || 0,
                        type: variationTile.type,
                        isJoker: false
                    };
                    
                    matchedTiles.push(matchInfo);
                    variationTile.matched = true;
                    variationTile.matchedTile = handTile;
                    matched = true;
                    
                    console.log('  Added match:', matchInfo);
                    break;
                }
            }
            
            if (!matched) {
                console.log(`No match found for hand tile: ${handTile}, adding to remaining hand`);
                remainingHand.push(handTile);
            }
        }
        
        // Add all jokers to remaining hand for joker matching
        console.log(`Adding ${jokerTiles.length} jokers to remaining hand`);
        remainingHand.push(...jokerTiles);
        
        // Update hand to only include unmatched tiles
        this.hand = remainingHand;
        this.matchedTiles = [...this.matchedTiles, ...matchedTiles];
        
        console.log('=== EXACT MATCHING COMPLETE ===');
        console.log('Matched tiles:', matchedTiles);
        console.log('Remaining hand after exact matching:', remainingHand);
        
        return { matchedTiles };
    }
    
    matchWithJokers(jokerTiles) {
        console.log('\n=== STARTING JOKER MATCHING ===');
        console.log('Jokers to try to place:', jokerTiles);
        
        const jokerMatches = [];
        // Track jokers by their index in the original hand to handle duplicate jokers
        const usedJokerIndices = new Set();
        let jokerComparisons = 0;
        
        // Create an array of joker indices to track which jokers we've used
        let jokerIndices = [];
        for (let i = 0; i < this.hand.length; i++) {
            if (this.hand[i].toUpperCase() === 'J') {
                jokerIndices.push(i);
            }
        }
        
        // Process each joker one by one using their indices
        while (jokerIndices.length > 0) {
            const jokerIndex = jokerIndices.shift(); // Take the first joker index
            const joker = this.hand[jokerIndex];
            
            if (usedJokerIndices.has(jokerIndex)) {
                console.log(`Skipping already used joker at index ${jokerIndex}`);
                continue;
            }
            
            console.log(`\nProcessing joker: ${joker}`);
            let jokerPlaced = false;
            
            // Notify that we're starting to match this joker
            this.jcheck++; // Increment local counter
            if (typeof this.onJokerMatchAttempt === 'function') {
                this.onJokerMatchAttempt();
            }
            
            // Find the first available valid slot in the variation
            for (const slot of this.variation) {
                jokerComparisons++;
                
                // Skip if slot is already matched or not a valid joker slot
                if (slot.matched) {
                    console.log(`  Skip slot ${slot.tile} (already matched)`);
                    continue;
                }
                
                if (!this.isValidJokerSlot(slot)) {
                    console.log(`  Skip slot ${slot.tile} (not a valid joker slot)`);
                    continue;
                }
                
                console.log(`  Found valid slot for joker:`, slot);
                
                // Assign joker to this slot
                slot.matched = true;
                slot.matchedTile = joker;
                slot.usedJoker = true;
                usedJokerIndices.add(jokerIndex);
                jokerPlaced = true;
                
                const matchInfo = {
                    handTile: joker,
                    variationTile: slot.tile,
                    groupIndex: slot.groupIndex,
                    position: slot.positionInGroup || 0,
                    type: slot.type,
                    isJoker: true
                };
                
                jokerMatches.push(matchInfo);
                console.log(`  Assigned joker ${joker} to slot ${slot.tile} in group ${slot.groupIndex}`, matchInfo);
                break; // Move to next joker after placing this one
            }
            
            if (!jokerPlaced) {
                console.log(`  Could not place joker ${joker} - no valid slots available`);
                // Put the joker back at the end of the queue to try again later
                jokersToPlace.push(joker);
                
                // If we've gone through all jokers and couldn't place any, break to avoid infinite loop
                if (jokerIndices.every(idx => usedJokerIndices.has(idx) || this.hand[idx] === joker)) {
                    console.log('No more jokers can be placed, stopping');
                    break;
                }
            }
        }
        
        console.log('=== JOKER MATCHING COMPLETE ===');
        console.log('Jokers used:', usedJokerIndices.size);
        console.log('Joker matches:', jokerMatches);
        
        return {
            usedJokers: usedJokerIndices.size,
            jokerMatches,
            jokerComparisons
        };
    }
    
    calculateScore() {
        return this.variation.filter(slot => slot.matched).length;
    }
    
    tilesMatch(tileA, tileB) {
        // If either tile is a joker, they don't match (jokers are handled separately)
        if ((typeof tileA === 'string' && tileA.toUpperCase().startsWith('J')) || 
            (typeof tileB === 'string' && tileB.toUpperCase().startsWith('J'))) {
            return false;
        }
        
        // Case-insensitive match for tile codes (e.g., '1b', 'N', 'F')
        const valA = String(tileA || '').toLowerCase();
        const valB = String(tileB || '').toLowerCase();
        
        // Special handling for flower tiles (all flowers match each other)
        if ((valA === 'f' || valA.startsWith('f') || valA.endsWith('f')) &&
            (valB === 'f' || valB.startsWith('f') || valB.endsWith('f'))) {
            return true;
        }
        
        return valA === valB;
    }
    
    isValidJokerSlot(slot) {
        // Jokers can only be used in pungs, kongs, or quints
        const validTypes = ['pung', 'kong', 'quint'];
        const slotType = (slot.type || '').toLowerCase();
        const isValid = validTypes.includes(slotType);
        
        console.log(`  Slot ${slot.tile} details:`, {
            type: slot.type,
            groupIndex: slot.groupIndex,
            positionInGroup: slot.positionInGroup,
            matched: slot.matched,
            isValidForJoker: isValid,
            validTypes: validTypes
        });
        
        return isValid;
    }
}

// --- Template 5: NorthSouthOddNumbersTemplate ---
class NorthSouthOddNumbersTemplate extends HandTemplate {
    constructor() {
        super({
            templateId: 'north_south_odd_numbers',
            name: 'North South Odd Numbers in 3 Suits',
            description: 'Kongs of N and S, then for one odd number (1,3,5,7,9): a single in suit1, a pair in suit2, and a pung in suit3, across all 6 permutations of suits.',
            category: 'Winds - Dragons',
            pointValue: 25,
            number: 6 // As specified by user
        });
    }

    generateVariations() {
        const variations = [];
        const SUITS = ['bam', 'crack', 'dot']; // Full suit names
        const ODD_NUMBERS = [1, 3, 5, 7, 9];

        for (const oddNum of ODD_NUMBERS) {
            // Generate all 6 permutations of SUITS
            for (let i = 0; i < SUITS.length; i++) {
                for (let j = 0; j < SUITS.length; j++) {
                    if (i === j) continue;
                    for (let k = 0; k < SUITS.length; k++) {
                        if (k === i || k === j) continue;

                        const suit1 = SUITS[i]; // e.g., 'bam'
                        const suit2 = SUITS[j];
                        const suit3 = SUITS[k];

                        const currentVariationSlots = [];
                        let groupIndex = 0;

                        // Kong of North Wind
                        currentVariationSlots.push(...this._createTileGroup('N', 4, 'kong', groupIndex++));
                        // Kong of South Wind
                        currentVariationSlots.push(...this._createTileGroup('S', 4, 'kong', groupIndex++));
                        
                        // Single of oddNum in suit1 (e.g., '1bam')
                        currentVariationSlots.push(...this._createTileGroup(`${oddNum}${suit1}`, 1, 'single', groupIndex++));
                        // Pair of oddNum in suit2 (e.g., '1crack')
                        currentVariationSlots.push(...this._createTileGroup(`${oddNum}${suit2}`, 2, 'pair', groupIndex++));
                        // Pung of oddNum in suit3 (e.g., '1dot')
                        currentVariationSlots.push(...this._createTileGroup(`${oddNum}${suit3}`, 3, 'pung', groupIndex++));

                        if (currentVariationSlots.length === 14) {
                            variations.push({
                                name: `N/S Kongs, ${oddNum}s: ${suit1[0].toUpperCase()}(Sgl), ${suit2[0].toUpperCase()}(Pr), ${suit3[0].toUpperCase()}(Pg)`,
                                slots: currentVariationSlots,
                                // Use full suit names in description for clarity
                                description: `Kongs of N & S. Single ${oddNum}${suit1}, Pair ${oddNum}${suit2}, Pung ${oddNum}${suit3}.`
                            });
                        }
                    }
                }
            }
        }
        return variations;
    }

    _createTileGroup(tileCode, count, type, groupIndex) {
        const group = [];
        for (let i = 0; i < count; i++) {
            group.push({
                type,
                tile: tileCode, // The specific tile code, e.g., '1b', 'N'
                value: tileCode, // Actual tile value
                groupIndex: groupIndex,
                positionInGroup: i,
                matched: false,
                usedJoker: false
            });
        }
        return group;
    }
    validateHand(tiles) { return { matched: false, score: 0, matchedTiles: [] }; }
}

// --- Hand Analyzer Core ---
class HandAnalyzer {
    constructor() {
        this.templates = [];
        this.tileMatcher = new TileMatcher();
        this.initializeTemplates();
    }
    initializeTemplates() {
        this.templates.push(new SequenceAndKongsTemplate());
        this.templates.push(new Symmetrical13579AllSuitsTemplate());
        this.templates.push(new KongKongPairWithFlowersAndDragonsTemplate());
        this.templates.push(new EvenChowEvenPungsFlowersTemplate());
        this.templates.push(new NorthSouthOddNumbersTemplate());
    }
    analyzeHand(hand) {
        if (!hand || hand.length === 0) {
            return [];
        }
        // Count jokers (case insensitive)
        const jokers = hand.filter(tile => tile.toUpperCase().startsWith('J')).length;
        console.log(`Analyzing hand with ${jokers} jokers`);
        const results = [];
        this.templates.forEach(template => {
            const { 
                bestOverallMatch, 
                maxMatchedTilesCount, 
                countMaxTilesVariations, 
                topTierMatchResults, 
                totalGeneratedVariations,
                jcheck = 0 
            } = this.analyzeTemplate(template, [...hand], jokers);

            if (bestOverallMatch) { // A best overall match (by score) was found
                results.push({
                    templateId: template.templateId,
                    templateName: template.name,
                    category: template.category,
                    pointValue: template.pointValue,
                    ...bestOverallMatch, // Spread details of the highest scoring match for detailed view
                    summaryMatchedTiles: maxMatchedTilesCount, // 't' for summary
                    summaryVariationCount: countMaxTilesVariations, // 'v' for summary
                    topTierMatchResults: topTierMatchResults, // Array of match results for highlighting
                    summaryTotalVariations: totalGeneratedVariations, // Total variations for this template
                    jcheck // Total joker matching attempts across all variations
                });
            }
        });
        results.sort((a, b) => b.score - a.score);
        return results;
    }
    analyzeTemplate(template, nonJokerTiles, availableJokers) {
        let bestOverallMatch = null;
        let maxMatchedTilesCount = -1;
        const allMatchResults = []; // This will store results from the first loop
        const topTierMatchResults = []; // Stores matchResults for variations achieving maxMatchedTilesCount
        
        // Initialize joker matching attempt counter
        let jcheck = 0;

        const variations = template.generateVariations();
        const totalGeneratedVariations = variations ? variations.length : 0;

        if (!variations || variations.length === 0) {
            return { 
                bestOverallMatch: null, 
                maxMatchedTilesCount: 0, 
                countMaxTilesVariations: 0, 
                topTierMatchResults: [], 
                totalGeneratedVariations: 0,
                jcheck: 0
            };
        }

        // Create a new TileMatcher instance with a callback to track joker checks
        const tileMatcher = new TileMatcher();
        tileMatcher.onJokerMatchAttempt = () => {
            jcheck++;
            return jcheck; // Return the updated count
        };

        // 1st loop: find maxMatchedTilesCount and bestOverallMatch
        for (let i = 0; i < variations.length; i++) {
            const variation = variations[i];
            const matchResult = tileMatcher.matchVariation(nonJokerTiles, variation, availableJokers);
            
            // Store the current jcheck value with this match result
            matchResult.jcheck = jcheck;
            allMatchResults.push(matchResult);

            if (!bestOverallMatch || matchResult.score > bestOverallMatch.score) {
                bestOverallMatch = matchResult;
            }

            if (matchResult.matchedTilesCount > maxMatchedTilesCount) {
                maxMatchedTilesCount = matchResult.matchedTilesCount;
            }
        }


        // 2nd loop: collect variations achieving maxMatchedTilesCount
        if (maxMatchedTilesCount > -1 && allMatchResults.length > 0) {
            for (let i = 0; i < allMatchResults.length; i++) {
                const res = allMatchResults[i];
                if (res.matchedTilesCount === maxMatchedTilesCount) {
                    // Update each top tier result with the current jcheck
                    res.jcheck = jcheck;
                    topTierMatchResults.push(res);
                }
            }
        }
        const countMaxTilesVariations = topTierMatchResults.length;
        return { 
            bestOverallMatch, 
            maxMatchedTilesCount, 
            countMaxTilesVariations, 
            topTierMatchResults, 
            totalGeneratedVariations,
            jcheck // Include the jcheck counter in the return object
        };
    }
}
const handAnalyzer = new HandAnalyzer();

// --- Highlighting Logic ---
function updateHandHighlighting(naturalTilesToHighlight, usedJokersCount) {
    const handDisplay = document.getElementById('handDisplay');
    if (!handDisplay) return;
    
    const displayedTileElements = Array.from(handDisplay.children);

    // 1. Clear all existing highlights
    displayedTileElements.forEach(tileEl => tileEl.classList.remove('tile-highlighted'));

    if ((!naturalTilesToHighlight || naturalTilesToHighlight.length === 0) && !usedJokersCount) {
        return; // Nothing to highlight
    }

    const tilesToHighlightCopy = naturalTilesToHighlight ? [...naturalTilesToHighlight] : [];
    let jokersToHighlight = usedJokersCount || 0;
    
    console.log('updateHandHighlighting - Input:', { 
        naturalTilesToHighlight, 
        usedJokersCount,
        tilesToHighlightCopy,
        jokersToHighlight 
    });

    // 2. First pass: try to match exact tile codes from data-code attribute
    for (const tileEl of displayedTileElements) {
        if (!tileEl.dataset.code) continue;
        
        const tileCode = tileEl.dataset.code.toLowerCase();
        const indexInCopyToHighlight = tilesToHighlightCopy.findIndex(t => 
            t && t.toString().toLowerCase() === tileCode
        );
        
        if (indexInCopyToHighlight !== -1) {
            tileEl.classList.add('tile-highlighted');
            tilesToHighlightCopy.splice(indexInCopyToHighlight, 1);
            console.log('Highlighted tile (exact match):', tileCode);
        }
    }

    // 3. Second pass: try to match by value + suit for remaining tiles
    if (tilesToHighlightCopy.length > 0) {
        for (const tileEl of displayedTileElements) {
            if (tilesToHighlightCopy.length === 0) break;
            if (tileEl.classList.contains('tile-highlighted')) continue;
            
            const suit = (tileEl.dataset.suit || '').toLowerCase();
            const value = (tileEl.dataset.value || '').toLowerCase();
            
            // Skip jokers in this pass (they're handled separately)
            if (suit === 'joker') continue;
            
            // Try different formats to match the tile
            let tileCode = '';
            if (['bam', 'crack', 'dot'].includes(suit)) {
                tileCode = value + suit[0]; // e.g., '1b', '5c', '9d'
            } else if (suit === 'wind' || suit === 'dragon' || suit === 'flower') {
                tileCode = value; // e.g., 'e', 's', 'rd', 'gd', 'f'
            }
            
            const indexInCopyToHighlight = tilesToHighlightCopy.findIndex(t => 
                t && t.toString().toLowerCase() === tileCode
            );
            
            if (indexInCopyToHighlight !== -1) {
                tileEl.classList.add('tile-highlighted');
                tilesToHighlightCopy.splice(indexInCopyToHighlight, 1);
                console.log('Highlighted tile (value+suit match):', tileCode);
            }
        }
    }

    // 4. Highlight jokers
    if (jokersToHighlight > 0) {
        for (const tileEl of displayedTileElements) {
            if (jokersToHighlight === 0) break;
            if ((tileEl.dataset.suit || '').toLowerCase() === 'joker' && 
                !tileEl.classList.contains('tile-highlighted')) {
                tileEl.classList.add('tile-highlighted');
                jokersToHighlight--;
                console.log('Highlighted joker');
            }
        }
    }
    
    if (tilesToHighlightCopy.length > 0) {
        console.warn('Could not find the following tiles to highlight:', tilesToHighlightCopy);
    }
}

// --- UI Interaction ---
function createTileElement(tileCode) {
    if (!tileCode) return null;

    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.dataset.code = tileCode; // Store original code for debugging/sorting
    // ... rest of your code remains the same ...

    let suit = '', value = '';

    if (tileCode.startsWith('j')) { // Joker
        tile.textContent = 'JOK'; // Short for Joker
        tile.classList.add('joker');
        suit = 'JOKER';
        value = tileCode; // e.g., j1
    } else if (tileCode === 'F') { // Flower
        tile.textContent = 'FLR'; // Short for Flower
        tile.classList.add('flower');
        suit = 'FLOWER';
        value = 'F';
    } else if (['e', 's', 'w', 'n'].includes(tileCode.toLowerCase())) { // Winds
        tile.textContent = tileCode.toUpperCase();
        tile.classList.add('wind');
        suit = 'WIND';
        value = tileCode;
    } else if (['rd', 'gd', 'wd'].includes(tileCode.toLowerCase())) { // Dragons
        tile.textContent = tileCode.toUpperCase();
        tile.classList.add('dragon');
        if (tileCode.toLowerCase() === 'rd') tile.classList.add('dragon-rd');
        else if (tileCode.toLowerCase() === 'gd') tile.classList.add('dragon-gd');
        else if (tileCode.toLowerCase() === 'wd') tile.classList.add('dragon-wd');
        suit = 'DRAGON';
        value = tileCode;
    } else { // Suited tiles: 1bam, 5dot, 9crack etc.
        const match = tileCode.match(/^(\d+)([a-z]+)$/);
        if (match) {
            const num = match[1];
            const suitName = match[2];
            tile.textContent = num; // Display the number
            const suitSpan = document.createElement('span');
            // suitSpan.style.fontSize = '0.7em'; // Handled by .tile span CSS
            // suitSpan.style.display = 'block';
            suitSpan.textContent = suitName.substring(0,1).toUpperCase(); // B, C, D
            tile.appendChild(suitSpan);

            tile.classList.add(suitName); // e.g., 'bam', 'crack', 'dot' for specific styling
            suit = suitName.toUpperCase();
            value = num;
        } else {
            tile.textContent = tileCode; // Fallback for unknown
        }
    }
    tile.dataset.suit = suit;
    tile.dataset.value = value; // Store parsed value for sorting

    return tile;
}

const SUIT_ORDER = { BAM: 1, CRACK: 2, DOT: 3, WIND: 4, DRAGON: 5, FLOWER: 6, JOKER: 7 };
const WIND_ORDER = { e: 1, s: 2, w: 3, n: 4 };
const DRAGON_ORDER = { rd: 1, gd: 2, wd: 3 };

function getTileSortableValues(tileCode) {
    let suit, valueNum, suitOrder, valueOrder;

    if (tileCode.startsWith('j')) {
        suit = 'JOKER';
        valueNum = parseInt(tileCode.substring(1)) || 0;
    } else if (tileCode === 'F') {
        suit = 'FLOWER';
        valueNum = 1;
    } else if (['e', 's', 'w', 'n'].includes(tileCode.toLowerCase())) {
        suit = 'WIND';
        valueNum = WIND_ORDER[tileCode.toLowerCase()];
    } else if (['rd', 'gd', 'wd'].includes(tileCode.toLowerCase())) {
        suit = 'DRAGON';
        valueNum = DRAGON_ORDER[tileCode.toLowerCase()];
    } else {
        const match = tileCode.match(/^(\d+)([a-z]+)$/);
        if (match) {
            valueNum = parseInt(match[1]);
            suit = match[2].toUpperCase();
        } else {
            suit = 'UNKNOWN'; valueNum = 99;
        }
    }
    suitOrder = SUIT_ORDER[suit] || 99;
    valueOrder = valueNum;
    return { suit, valueNum, suitOrder, valueOrder };
}

function sortHand(handArray, sortBySuitPrimary = true) {
    handArray.sort((a, b) => {
        const valA = getTileSortableValues(a);
        const valB = getTileSortableValues(b);

        if (sortBySuitPrimary) {
            if (valA.suitOrder !== valB.suitOrder) {
                return valA.suitOrder - valB.suitOrder;
            }
            return valA.valueOrder - valB.valueOrder;
        } else { // Sort by Number (value) first
            if (valA.valueOrder !== valB.valueOrder) {
                return valA.valueOrder - valB.valueOrder;
            }
            return valA.suitOrder - valB.suitOrder;
        }
    });
}

function renderHand(handArray, displayElement) {
    displayElement.innerHTML = ''; // Clear previous display
    if (!handArray || handArray.length === 0) {
        displayElement.textContent = '(No hand yet)';
        return;
    }
    handArray.forEach(tileCode => {
        const tileEl = createTileElement(tileCode);
        if (tileEl) {
            displayElement.appendChild(tileEl);
        }
    });
}

// --- UI Logic ---
let currentHand = [];
const handDisplay = document.getElementById('handDisplay');
const resultDisplay = document.getElementById('resultDisplay');



document.getElementById('generateBtn').onclick = function() {
    currentHand = generateRandomHand();
    renderHand(currentHand, handDisplay);
    resultDisplay.textContent = '(No analysis yet)';
    const summaryDisplayElement = document.getElementById('analysisSummaryDisplay');
    if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear summary display
};
document.getElementById('analyzeBtn').onclick = function() {
    const detailedResultDisplay = document.getElementById('resultDisplay');
    const summaryDisplayElement = document.getElementById('analysisSummaryDisplay'); // Get reference

    if (!currentHand || currentHand.length === 0) { // More robust check
        if(detailedResultDisplay) detailedResultDisplay.textContent = '(Generate a hand first)';
        if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear summary display as well
        return;
    }
    const analysisResultsArray = handAnalyzer.analyzeHand(currentHand);

    // Populate Summary Display
    if (summaryDisplayElement) summaryDisplayElement.innerHTML = ''; // Clear previous summary
    if (analysisResultsArray && analysisResultsArray.length > 0) {
        analysisResultsArray.forEach(templateAnalysis => {
            const row = document.createElement('div');
            row.className = 'summary-row';
            row.dataset.templateId = templateAnalysis.templateId; // For future click functionality
            
            // Store the detailed match results for highlighting and initialize variation index
            row.topTierMatchResults = templateAnalysis.topTierMatchResults || []; // Ensure it's an array
            row.dataset.currentVariationIndex = -1; // Initialize for cycling through variations

            // Get the joker comparison count from the best match (first in topTierMatchResults)
            const jokerComparisons = templateAnalysis.topTierMatchResults?.[0]?.jokerComparisons ?? 0;
            
            const mainText = `${templateAnalysis.templateName} tiles=${templateAnalysis.summaryMatchedTiles} vars=${templateAnalysis.summaryVariationCount} totvars=${templateAnalysis.summaryTotalVariations} jcheck=${jokerComparisons}`;
            
            const variationDisplaySpan = document.createElement('span');
            variationDisplaySpan.className = 'variation-display';
            // This span will be updated on click to show e.g., "(Variation 1 of 3)"

            row.innerHTML = mainText + ' ';
            row.appendChild(variationDisplaySpan);
            
            if (summaryDisplayElement) summaryDisplayElement.appendChild(row);
        });
    } else {
        if (summaryDisplayElement) summaryDisplayElement.textContent = '(No analysis summary available)';
    }

    // Populate Detailed JSON Display
    const jsonString = JSON.stringify(analysisResultsArray, null, 2);
    detailedResultDisplay.textContent = jsonString;

    // Add click listener for summary rows to handle highlighting
    if (summaryDisplayElement) {
        summaryDisplayElement.removeEventListener('click', handleSummaryRowClick); // Remove old listener if any
        summaryDisplayElement.addEventListener('click', handleSummaryRowClick);
    }
};

function handleSummaryRowClick(event) {
    const clickedRow = event.target.closest('.summary-row');
    if (!clickedRow) return;

    const topMatches = clickedRow.topTierMatchResults;
    if (!topMatches || topMatches.length === 0) {
        updateHandHighlighting([], 0); // Clear highlights if no variations
        const variationDisplay = clickedRow.querySelector('.variation-display');
        if (variationDisplay) variationDisplay.textContent = '';
        return;
    }

    let currentIndex = parseInt(clickedRow.dataset.currentVariationIndex, 10);
    currentIndex++;
    if (currentIndex >= topMatches.length) {
        currentIndex = 0;
    }
    clickedRow.dataset.currentVariationIndex = currentIndex;

    const currentMatch = topMatches[currentIndex];
    
    // Extract tile codes from matchedTiles array (which contains objects)
    const matchedTileCodes = currentMatch.matchedTiles.map(tileObj => {
        // If it's already a string (tile code), return it as is
        if (typeof tileObj === 'string') return tileObj;
        // Otherwise, extract the tile code from the object
        return tileObj.handTile || tileObj.value || tileObj.tile;
    });
    
    console.log('Highlighting tiles:', matchedTileCodes, 'with jokers:', currentMatch.usedJokers);
    updateHandHighlighting(matchedTileCodes, currentMatch.usedJokers || 0);

    const variationDisplay = clickedRow.querySelector('.variation-display');
    if (variationDisplay) {
        if (topMatches.length > 0) {
            variationDisplay.textContent = `(Variation ${currentIndex + 1} of ${topMatches.length})`;
        } else {
            variationDisplay.textContent = '';
        }
    }
}

document.getElementById('sortSuitBtn').onclick = function() {
    if (!currentHand.length) return;
    sortHand(currentHand, true); // true for sortBySuitPrimary
    renderHand(currentHand, handDisplay);
};

document.getElementById('sortNumBtn').onclick = function() {
    if (!currentHand.length) return;
    sortHand(currentHand, false); // false for sortBySuitPrimary (so sort by number first)
    renderHand(currentHand, handDisplay);
};

// Load TypeScript utilities
const tsScript = document.createElement('script');
tsScript.type = 'module';
tsScript.textContent = `
    import { tsUtils } from './dist/index.js';
    window.tsUtils = tsUtils;
    console.log('TypeScript utilities loaded:', Object.keys(tsUtils));
`;
document.body.appendChild(tsScript);
</script>
</body>
</html>
